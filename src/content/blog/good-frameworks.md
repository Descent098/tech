---
title: Good Frameworks In Frontend
subtitle: Is it possible? What does it take
description: What does the frontend landscape look like at the end of 2025, and what choices do I make
pubDate: 2025-12-01
heroImage: /tech/blog/good-frameworks.jpg
tags:
  - web
  - javascript
  - css
  - js
  - html
  - frontend
  - ui-ux
  - design
---

A while ago I talked about the dangers of [learning web frameworks instead of technologies](../dont-learn-frameworks/). In my career so far I have exclusively been using plain javascript, and interacting with the DOM directly. This has allowed me to move fairly quickly when developing, while offering broad support for the systems I create because they don't have many (if any) underlying dependencies. These are all strong technical reasons for why I never used frameworks, but a less technical one was just that they didn't make things faster for me. Some people will call this a skill issue (they're right and wrong about that). What I found was that a lot of the existing frameworks I was constantly hacking escape hatches to browser technologies because things just didn't work how they should. I later realized what was happening.

## The Shoulders we Stand On

When I write projects I'm constantly looking for ways to make what I'm doing re-usable. This is how many of the libraries that I've written have come about. There is a **huge** difference between writing **an application** and writing **a library**. 90%+ of the people saying I had a skill issue are people who just install other people's **libraries** to build their **applications**. The overwhelming majority of the logic doing the heavy lifting is being done by other people. For me I often build applications and **end up** with libraries at the end. [React](https://react.dev/), for example is great, if you never have to deal with the complexities of library code. If you just `npm install` a pacakge someone else wrote, and compose it with other projects other people wrote, react works great. If instead you want to do something novel that hasn't been created for you, react gets in the way constantly.

This isn't really a problem if you **only** care about writing application code, but if you ever want to write code that **other people** are going to use, it's a massive hassle. This by the way doesn't make react a bad project, or even this approach bad necessarily. React was designed to help [meta](https://www.meta.com/ca/) build out features for facebook and instagram (both applications). Doing this with raw DOM queries, and manually handling all the edge cases just isn't feasible on a project that large, complex, and riddled with legacy. I'm also sure if you live in the react world for everything long enough you learn enough of the tricks to write libraries effectively. I do not intend to use react for everything, nor am I actively being paid to use it. This means I need to decide purely based on the merits whether it's worth learning, and for someone who primarily uses **their own** code instead of just installing libraries from other people, react is not worth it.

## A quick break down

After some time reflecting I realized a lot of my issues with react were about react's philosophy. Much like the javascript colouring problem (the fact that one `async` makes basically your whole app require `async`), react demands **everything** to be react. React has a disdain for the web as a platform, and instead wants you to use the [virtual dom](https://legacy.reactjs.org/docs/faq-internals.html) that it perscribes for your entire app. If you're unfamiliar with some of the react internals react is actually two parts on the web, `react` itself and `react-dom`. I don't know all the terminology react uses these days so some of this next part is my own terms. React is a [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model), it maintains it's own information about what to render, when, and what's being changed. When a change needs to be made react will generate a diff of it's own internal tree, then push that to whatever consumer platform is using react to run (I think this is called [reconciliation](https://legacy.reactjs.org/docs/reconciliation.html)), on the web this is `react-dom`. `react-dom` then translates these differences into code that runs on the client to change the real DOM. This is supposed to come with benefits like:

- *Only updating what you need to*; But with the complexity of the framework you often end up with accidental re-rendering anyways. Take any fortune 500 company using react and you'll notice tons of whole page rerenders constantly
- *Cross-platform code*; Since the virtual dom is the same and you only swap consumers, you should be able to re-use the same react code on other platforms. I don't do a ton of native work these days, but based on what I've seen, my understanding is every native binding uses their own elements anyways (like `<Text>` instead of `<p>`). This means every platform ends up being different code with essentially **no library cross-compatability** for the most part, even with components that just handle state manipulations

This means effectively  that react infects your dom, and you cannot disentangle it. Yes, the react elements exist in the browser DOM, but the browser has 0 insight into the choices react is making most of the time. Your "components" aren't actually separate in react projects, they instead form a heirarchy where the page you're on is the root of the tree. Once you have react setup in a project, the dom nodes that use react cannot interoperate with other web technologies outside react because they're managed by react. On the client you can never rely on anything like a `document.getElementby` function because react can kill and move things unpredictably with re-renders. This means to use any existing javascript packages you must reactify them. Everything must bow to react to be allowed to play.

As react moves more towards SSR, and complicated [serverless solutions](https://www.cloudflare.com/learning/serverless/what-is-serverless/) to avoid it's problems (and create new ones), you end up with even more complex issues. In practicality to use react at all you have to bootstrap so many packages, or deeply understand the framework enough to bootstrap it yourself (I [did this](https://github.com/Descent098/react-from-scratch) a few years ago and it's pretty ugly and finicky, [this is a better example](https://webdeveloper.beehiiv.com/p/build-react-400-lines-code)). At the end of this you still don't even have any of what you need to do a real application, you have to look to "meta-frameworks" for that, which increasingly means using [nextJS](https://nextjs.org/). So, now I have to buy into a perscribed server and client just to get what I want. If I ever decide to no longer reuse react, like say because their new version [completely changes the framework](https://medium.com/@ignatovich.dm/from-class-components-to-hooks-a-migration-strategy-28fe50b69669), I can't just port **part** of the application to see if it's worth it. Most of the time we have to re-do the **whole thing** since react **owns** your project. 

So, what's a guy to do...

## The Good Shoulders to Stand On

I had assumed in [my old post](../dont-learn-frameworks/) that this was the case of all frameworks, which meant it was not worth learning these frameworks due to my experience with react. After some time however, I've realized I was just looking at the wrong option. I could always articulate problems with react, but never really considered solutions since I didn't see the point. Everything I was doing was working, why bother. A few years ago I heard the creator of [AstroJS](https://astro.build/) give a presentation, and a lot of what he was saying made sense to me. Astro is a massive abstraction layer, but the abstraction layer serves a purpose I agree with. Astro was heavily focused on static generation, meaning it wanted as much as possible for things to run on a server, be built, sent down to the client, then hydrated later. This idea of letting webpages just be webpages was nice. You build it, and ship it, instead of wasting compute on constantly rendering on-demand every time I wanted something that allowed for a good separation between my backend and frontend, was efficient, and just worked for what I needed. Astro filled that gap for me. 

I could just simply run `npm run build` on my project, and serve those files, then use whatever backend I wanted. If I wanted to use react components (except server components), I could utilize their [islands](https://docs.astro.build/en/concepts/islands/) architecture and even combine them with whatever other frameworks I wanted in one project. All of this without a server to "handle" the runtime. I just started a site to show off my [components](https://kieranwood.ca/components/) and that site will use tons of different frameworks at once all in one codebase. This site had no "server" that's doing computation. It's just static files served over the network, that's it. Assuming the browser retains compatabiltiy for the features I have 0 maintenance burden on that site forevermore. If I want to change providers I copy my files somewhere new, set up a reverse proxy, and move on with my life.

Astro is also a [leaky abstraction](https://en.wikipedia.org/wiki/Leaky_abstraction), but it **actually delivers** on it's promises with it's advantages. The overwhelming majority of frontend projects I do now will use astro, including more complicated application frontends. It still certainly has it's issues, and complexities, but it's issues and complexities are all decisions that I can see the vision for. For example, the switch to [content collections](https://docs.astro.build/en/guides/content-collections/) in version 2->3 was annoying (especially since it happened right after I made a bunch of projects), but it does provide actual tangible advantages. You can load your data from **anywhere**, not just a folder of markdown files. It's a feature that works and offers a massive amount of freedom. Likewise issues with client-side components that interact with the dom are annoying on initial render, but it makes sense since there's literally no DOM on the server, and wouldn't be on any framework. 

So, astro is one of the good ones. Or, well the only good one, unless...

## A New Challenger

You may have noticed that astro solves some of the problems I talked about before, but the whole point of react was, well reactivity. Moving everything to the server is great for cases where react already made no sense, but what about the cases where react **would** make sense? Being able to listen to changes and react to them, astro doesn't solve that at all. For a long time I didn't really need it, everything I was doing was working... when I was completely focused on my projects. Unfortunately, life often gets in the way, and these days I cannot spend all my time focusing on projects. This means that the elegant and complicated dances I was doing with state management before are just not as sustainable as I thought. I dreaded the idea of using one of these frameworks, but after some issues came up in a recent project I caved and decided I would need a "reactive framework".

When I looked around initially I knew I didn't want [react](https://react.dev/), [vue](https://vuejs.org/), [svelte](https://svelte.dev/) etc. since they were client side heavy, and I only needed a bit of reactivity. So, I looked at [solidJS](https://www.solidjs.com/), and it philosophically looked good, but i hated the API. The keen-eyed among you may have noticed I actually lied earlier. I thought [svelte](https://svelte.dev/) was a client-heavy framework like the rest, but boy was I wrong. Turns out that svelte is a compiler. It takes your code, and compiles it to native javascript, inserting techniques that make the most sense for what you're trying to do. On top of that it offers the same sorts of affordances as [web components](https://www.webcomponents.org/introduction), but with a nicer API. I later found out you can actually [export svelte components as web components](https://svelte.dev/docs/svelte/custom-elements), meaning I don't even have to stick with astro if I don't want to. I can just export my components and use them in literally any stack I want with any backend javscript-based or not.

The svelte team in general has the philosophy that the browser has tons of great features, but just makes it hard to use them appropriately. Svelte is designed to work **with the browser** not against it. It's been the first reactive framework I've used that **actually clicks** with me, since it's just normal web development, but better. The principles are essentially the same, but just with nice-to-have's. Even If I decide I absolutely hate svelte in the future it just uses normal web technologies like a normal script tag, a normal style tag etc. with it's own magic sprinkled in. Meaning I can transfer everything over to something like a plain web component, and just make my own magic to handle reactivity (like if native [signals](https://github.com/tc39/proposal-signals) become a thing). Astro and svelte also go together beautifully. If I decide I want to make my app more dynamic, swapping over to [svelte kit](https://svelte.dev/docs/kit/introduction) (with the static adapter) it just a matter of copying my components, and recreating the equivalent `.astro` pages as `.svelte` pages in sveltekit.

## Give the Devil It's Due

It's also the case that astro and svelte benefitted quite a lot from the major browser changes and enhancements that happened since react was created. Lots of the features you can use natively in the browser used to require [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill). Likewise react is getting on in years and because of that react is a massive project. If you combined the lines of code for astro and svelte together, based on napkin math estimates the two combined are less than 1/5 the size of just the react codebase. This means you really can't make the sorts of leaps and changes that astro and svelte have been making without pissing a lot of people off, such as the paradigm shifts made in [svelte 5](https://svelte.dev/docs/svelte/v5-migration-guide), and the [content collection changes](https://docs.astro.build/en/guides/content-collections/) in astro I mentioned earlier. Massive sweeping changes like that are just not possible to do in a project like react, which means you really are stuck with what you have now, and working with the mess that exists from the past.

## Get to the point

So, with these modern iterations of frameworks what I've realized is I just want technololgies that work **with** what exists, not try to reinvent every wheel and create additional conceptual complexity. I want to learn browser standards and have my skills be transferrable as much as possible, which is what [astro](https://astro.build/) and [svelte](https://svelte.dev/docs/svelte/overview) encourage, compared to [nextJS](https://nextjs.org/) and [react](https://react.dev/) that assume "they know bettter". I think there is hope for a brighter future. People recognize the dangers of the maintenance burden react has, and no longer want to do everything "their way". Lastly compared to where my understanding was when I first wrote that old post, I think there **are** good options for frontend frameworks. You should just **choose them carefully** based on what they value and the approach they take making sure they:

1. **Build on the web and it's standards**, not try to replace them all with their own systems
2. Encourage approaches **that benefit users**, not just look/seem interesting (or personally profitable)
3. **Reduce complexity** where possible, and leverage **universal solutions** where it isn't ([Stores](https://svelte.dev/docs/svelte/stores) and [view transitions](https://docs.astro.build/en/guides/view-transitions/) are good examples)
4. Ensure the team building it isn't just **playing with new toys**, the decision making they put into the choices they make is important, and read up on **why** they make the changes they do
